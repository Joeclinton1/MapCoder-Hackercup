{
    "Fall in Line": 
        {
            "trick": "\nOptimal Line Finding: Instead of checking all O(N^2) pairs of ants to find a line, use a probabilistic approach by randomly selecting 2 ants to define a line.\nCount Ants on a Line: For each line defined by the chosen pair, count how many ants lie on it in O(N) time.\nBounds on Movements: Calculate M = N - P, where P is the maximum number of ants on a line. Any answer between M and 2M is acceptable.\nProbability and Trials: Run multiple trials (denoted as K) to increase the likelihood of finding a line that includes a significant number of ants. The algorithm's success rate improves with more trials.\nEfficiency: The algorithm's efficiency comes from avoiding exhaustive pairwise comparisons, instead relying on random selections and statistical properties to find optimal configurations quickly.\n",
            "correct_plan1": "function alignAnts(T, test_cases):\n    for i from 1 to T:\n        N = test_cases[i].N\n        ants = test_cases[i].coordinates\n\n        max_on_line = 0\n        \n        // Perform K trials to find the line with the most ants\n        K = 40  // Number of trials\n        for j from 1 to K:\n            // Randomly select two distinct ants\n            a1, a2 = randomly select two distinct ants from ants\n            \n            // Compute the line equation using the two points\n            line = computeLine(a1, a2)\n\n            // Count how many ants lie on this line\n            count = countAntsOnLine(ants, line)\n\n            // Update the maximum number of ants on a line found\n            if count > max_on_line:\n                max_on_line = count\n\n        // Calculate the number of ants to move\n        ants_to_move = N - max_on_line\n\n        // Output the result for the current case\n        print(\"Case #\", i, \": \", ants_to_move)\n\nfunction computeLine(point1, point2):\n    // Return the line parameters (slope and intercept or equivalent)\n    // For vertical lines, handle separately\n\nfunction countAntsOnLine(ants, line):\n    count = 0\n    for each ant in ants:\n        if isOnLine(ant, line):\n            count += 1\n    return count\n\nfunction isOnLine(point, line):\n    // Check if the point satisfies the line equation\n    // Handle edge cases like vertical lines\n",
            "wrong_plan1": "function alignAnts(T, test_cases):\n    for i from 1 to T:\n        N = test_cases[i].N\n        ants = test_cases[i].coordinates\n\n        max_on_line = 0\n        \n        // Perform K trials to find the line with the most ants\n        K = 40  // Number of trials\n        for j from 1 to K:\n            // Randomly select two distinct ants\n            a1, a2 = randomly select two distinct ants from ants\n            \n            // Compute the line equation using the two points\n            line = computeLine(a1, a2)\n\n            // Count how many ants lie on this line\n            count = countAntsOnLine(ants, line)\n\n            // Update the maximum number of ants on a line found\n            if count > max_on_line:\n                max_on_line = count\n\n        // Calculate the number of ants to move\n        ants_to_move = max_on_line - N\n\n        // Output the result for the current case\n        print(\"Case #\", i, \": \", ants_to_move)\n\nfunction computeLine(point1, point2):\n    // Return the line parameters (slope and intercept or equivalent)\n    // For vertical lines, handle separately\n    return slope, intercept\n\nfunction countAntsOnLine(ants, line):\n    count = 0\n    for each ant in ants:\n        if isOnLine(ant, line):\n            count += 1\n    return count\n\nfunction isOnLine(point, line):\n    // Check if the point satisfies the line equation\n    // Handle edge cases like vertical lines\n",
            "wrong_code1": "\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <cstdlib>\n#include <ctime>\n#include <climits>\n#include <algorithm>\n\nstruct TestCase {\n    int N;\n    std::vector<std::pair<int, int>> coordinates; // (x, y) pairs\n};\n\nstd::pair<double, double> computeLine(const std::pair<int, int>& point1, const std::pair<int, int>& point2) {\n    if (point1.first == point2.first) {\n        return {INT_MAX, point1.first}; // Handle vertical line case\n    }\n    double slope = static_cast<double>(point2.second - point1.second) / (point2.first - point1.first);\n    double intercept = point1.second - slope * point1.first;\n    return {slope, intercept};\n}\n\nbool isOnLine(const std::pair<int, int>& point, const std::pair<double, double>& line) {\n    if (line.first == INT_MAX) {\n        return point.first == line.second; // Check for vertical line\n    }\n    return point.second == line.first * point.first + line.second; // Check line equation\n}\n\nint countAntsOnLine(const std::vector<std::pair<int, int>>& ants, const std::pair<double, double>& line) {\n    int count = 0;\n    for (const auto& ant : ants) {\n        if (isOnLine(ant, line)) {\n            count++;\n        }\n    }\n    return count;\n}\n\nvoid alignAnts(int T, const std::vector<TestCase>& test_cases) {\n    for (int i = 0; i < T; i++) {\n        int N = test_cases[i].N;\n        const auto& ants = test_cases[i].coordinates;\n\n        int max_on_line = 0;\n\n        // Perform K trials to find the line with the most ants\n        const int K = 40; // Number of trials\n        std::srand(static_cast<unsigned>(std::time(0))); // Seed for random number generator\n\n        for (int j = 0; j < K; j++) {\n            // Randomly select two distinct ants\n            int a1_index = std::rand() % N;\n            int a2_index;\n            do {\n                a2_index = std::rand() % N;\n            } while (a1_index == a2_index); // Ensure distinct ants\n\n            auto line = computeLine(ants[a1_index], ants[a2_index]);\n\n            // Count how many ants lie on this line\n            int count = countAntsOnLine(ants, line);\n\n            // Update the maximum number of ants on a line found\n            if (count > max_on_line) {\n                max_on_line = count;\n            }\n        }\n\n        // Calculate the number of ants to move\n        int ants_to_move = max_on_line - N;\n\n        // Output the result for the current case\n        std::cout << \"Case #\" << (i + 1) << \": \" << ants_to_move << std::endl;\n    }\n}\n\nint main() {\n    int T;\n    std::cin >> T;\n\n    std::vector<TestCase> test_cases(T);\n    for (int i = 0; i < T; i++) {\n        std::cin >> test_cases[i].N;\n        test_cases[i].coordinates.resize(test_cases[i].N);\n        for (int j = 0; j < test_cases[i].N; j++) {\n            std::cin >> test_cases[i].coordinates[j].first >> test_cases[i].coordinates[j].second;\n        }\n    }\n\n    alignAnts(T, test_cases);\n    return 0;\n}\n",
            "mistakes1": "Incorrect Calculation of Ants to Move:\nMistake: The line ants_to_move = max_on_line - N is incorrect. It should be ants_to_move = N - max_on_line. The goal is to calculate how many ants need to be moved to get to the optimal line, which is the total number of ants minus those already on the line.\n\nIncomplete Return in computeLine Function:\nMistake: The function computeLine should return the parameters needed to define the line, but only slope and intercept are mentioned without proper calculation or handling of vertical lines. This function should handle and return a more complete representation of the line (e.g., coefficients for the line equation) to accurately check if ants are on it.",
            "correct_plan2": "function align_ants(T, test_cases):\n    for i from 1 to T:\n        N = test_cases[i].N\n        coordinates = test_cases[i].coordinates\n\n        best_count = 0  // Maximum ants on a single line\n        K = 40  // Number of trials\n\n        for trial from 1 to K:\n            // Randomly select two distinct ants\n            ant1_index = random(0, N - 1)\n            ant2_index = random(0, N - 1)\n            while ant1_index == ant2_index:\n                ant2_index = random(0, N - 1)\n\n            ant1 = coordinates[ant1_index]\n            ant2 = coordinates[ant2_index]\n\n            // Calculate line coefficients (slope-intercept or line equation)\n            a = ant2.y - ant1.y\n            b = ant1.x - ant2.x\n            c = a * ant1.x + b * ant1.y  // Line equation: ax + by = c\n\n            count_on_line = 0\n            // Check how many ants lie on this line\n            for j from 0 to N - 1:\n                if a * coordinates[j].x + b * coordinates[j].y == c:\n                    count_on_line += 1\n\n            // Update the best count of ants on a single line\n            best_count = max(best_count, count_on_line)\n\n        // Calculate the minimum number of ants to move\n        M = N - best_count\n        print(\"Case #\", i, \": \", M, sep=\"\")\n",
            "wrong_plan2": "function align_ants(T, test_cases):\n    for i from 1 to T:\n        N = test_cases[i].N\n        coordinates = test_cases[i].coordinates\n\n        best_count = 0  // Maximum ants on a single line\n        K = 40  // Number of trials\n\n        for trial from 1 to K:\n            // Randomly select two distinct ants\n            ant1_index = random(0, N)  \n            ant2_index = random(0, N)  \n\n            while ant1_index == ant2_index:\n                ant2_index = random(0, N)  \n\n            ant1 = coordinates[ant1_index]\n            ant2 = coordinates[ant2_index]\n\n            // Calculate line coefficients (slope-intercept or line equation)\n            a = ant2.y - ant1.y\n            b = ant1.x - ant2.x\n            c = a * ant1.x + b * ant1.y  // Line equation: ax + by = c\n\n            count_on_line = 0\n            // Check how many ants lie on this line\n            for j from 0 to N - 1:\n                if a * coordinates[j].x + b * coordinates[j].y != c:  \n                    count_on_line += 1  \n\n            // Update the best count of ants on a single line\n            best_count = max(best_count, count_on_line)\n\n        // Calculate the minimum number of ants to move\n        M = N - best_count\n        print(\"Case #\", i, \": \", M, sep=\"\")\n",
            "wrong_code2": "\n#include <iostream>\n#include <iomanip>\n#include <numeric>\n#include <vector>\n#include <climits>\n#include <cstdlib>\n#include <ctime>\n#include <algorithm>\n\nstruct Ant {\n    long long x, y;\n};\n\nstruct TestCase {\n    int N;\n    std::vector<Ant> coordinates;\n};\n\nvoid align_ants(int T, const std::vector<TestCase>& test_cases) {\n    for (int i = 1; i <= T; ++i) {\n        int N = test_cases[i - 1].N;\n        const std::vector<Ant>& coordinates = test_cases[i - 1].coordinates;\n\n        int best_count = 0; // Maximum ants on a single line\n        int K = 40; // Number of trials\n\n        for (int trial = 1; trial <= K; ++trial) {\n            // Randomly select two distinct ants\n            int ant1_index = rand() % N;\n            int ant2_index = rand() % N;\n\n            while (ant1_index == ant2_index) {\n                ant2_index = rand() % N;\n            }\n\n            Ant ant1 = coordinates[ant1_index];\n            Ant ant2 = coordinates[ant2_index];\n\n            // Calculate line coefficients (slope-intercept or line equation)\n            long long a = ant2.y - ant1.y;\n            long long b = ant1.x - ant2.x;\n            long long c = a * ant1.x + b * ant1.y; // Line equation: ax + by = c\n\n            int count_on_line = 0;\n            // Check how many ants lie on this line\n            for (int j = 0; j < N; ++j) {\n                if (a * coordinates[j].x + b * coordinates[j].y != c) {\n                    count_on_line += 1;\n                }\n            }\n\n            // Update the best count of ants on a single line\n            best_count = std::max(best_count, count_on_line);\n        }\n\n        // Calculate the minimum number of ants to move\n        int M = N - best_count;\n        std::cout << \"Case #\" << i << \": \" << M << std::endl;\n    }\n}\n\nint main() {\n    std::srand(std::time(nullptr)); // Seed for randomness\n    int T;\n    std::cin >> T;\n    std::vector<TestCase> test_cases(T);\n\n    for (int i = 0; i < T; ++i) {\n        std::cin >> test_cases[i].N;\n        test_cases[i].coordinates.resize(test_cases[i].N);\n        for (int j = 0; j < test_cases[i].N; ++j) {\n            std::cin >> test_cases[i].coordinates[j].x >> test_cases[i].coordinates[j].y;\n        }\n    }\n\n    align_ants(T, test_cases);\n    return 0;\n}\n",
            "mistakes2": "\nIndexing Error in Random Selection:\nMistake: The random(0, N) should be random(0, N - 1) when selecting random indices for ants. This mistake allows the selection of an index equal to N, which is out of bounds, leading to an error or invalid access.\nLogical Error in Counting Ants:\nMistake: The condition if a * coordinates[j].x + b * coordinates[j].y != c should be == c to check if the ant lies on the line. Additionally, instead of incrementing count_on_line, it should decrement it when the condition is false, which means the ant is not on the line. This logic error leads to an incorrect count of ants on the line."
        },
    "Line by Line":
        {
            "trick": "\nThis approach provides a clever trick to determine how much to increase your typing accuracy (P%) to match the success probability of typing one line less. By converting P% to a decimal probability (p) and establishing the equation q^N = p^(N-1), where q represents the success probability for N lines, you can efficiently derive q using the formula q = p^((N-1)/N). After converting q back to a percentage, you can easily calculate the increase needed in P. This method highlights the power of mathematical manipulation to deliver a quick and effective solution, bypassing the need for trial and error.\n",
            "correct_plan1": "\nfunction main():\n    T = read integer\n    for i from 1 to T:\n        N, P = read integers\n        p = P / 100.0\n        q = pow(p, (N - 1) / N)\n        q_percentage = q * 100\n        increase = q_percentage - P\n        print(\"Case #\", i, \": \", increase, sep=\"\")\n",
            "wrong_plan1": "\nfunction main():\n    T = read integer\n    for i from 1 to T:\n        N, P = read integers\n        p = P / 100.0\n        q = pow(p, (N + 1) / N)\n        q_percentage = q * 100\n        increase = P - q_percentage\n        print(\"Case #\", i, \": \", increase, sep=\"\")\n",
            "wrong_code1": "\n#include <iostream>\n#include <iomanip>\n#include <cmath>\n#include <climits>\n#include <numeric>\n\nvoid calculateIncrease(int T) {\n    for (int i = 1; i <= T; ++i) {\n        long long N, P;\n        std::cin >> N >> P;\n        \n        double p = P / 100.0;\n        double q = pow(p, static_cast<double>(N + 1) / N);\n        double q_percentage = q * 100;\n        double increase = P - q_percentage;\n\n        // Output in the specified format\n        std::cout << \"Case #\" << i << \": \" << std::fixed << std::setprecision(6) << increase << std::endl;\n    }\n}\n\nint main() {\n    int T;\n    std::cin >> T;\n    \n    // Check for limits\n    if (T < 1 || T > INT_MAX) return 1;\n\n    // Call the function to calculate increases\n    calculateIncrease(T);\n\n    return 0;\n}\n\n",
            "mistakes1": "\nIncorrect Power Calculation: The exponent in the pow function should be (N - 1) / N instead of (N + 1) / N. This mistake will result in an incorrect calculation for q, which will ultimately yield erroneous results for the increase in probability needed.\n\nIncorrect Subtraction Order: The increase should be calculated as increase = q_percentage - P. The current code incorrectly subtracts q_percentage from P, which will produce an incorrect value for the increase needed to achieve the desired probability.\n",
            "correct_plan2": "\nfunction solve():\n    read T\n    for i from 1 to T:\n        read N, P\n        p = P / 100\n        q = pow(p, (N - 1) / N)\n        q_percent = q * 100\n        increase = q_percent - P\n        print(\"Case #\", i, \": \", increase)\n\nsolve()\n",
            "wrong_plan2": "\nfunction solve():\n    read T  # Read number of test cases\n    for i from 1 to T:\n        read N, P  # Read N (number of lines) and P (success rate)\n        \n        p = P / 1000\n        \n        # Calculate the required probability for N lines\n        q = pow(p, (N - 1) / N)  # Calculate q\n        \n        q_percent = q * 10\n        \n        # Calculate the increase needed\n        increase = q_percent - P\n        \n        # Format the result\n        print(\"Case #\", i, \": \", increase)  # Print result for each test case\n\nsolve()\n",
            "wrong_code2": "\n#include <iostream>\n#include <iomanip>\n#include <cmath>\n#include <climits>\n#include <numeric>\n\nvoid calculateIncrease(int T) {\n    for (int i = 1; i <= T; ++i) {\n        long long N, P;\n        std::cin >> N >> P;\n        \n        double p = P / 100.0;\n        double q = pow(p, static_cast<double>(N + 1) / N);\n        double q_percentage = q * 100;\n        double increase = P - q_percentage;\n\n        // Output in the specified format\n        std::cout << \"Case #\" << i << \": \" << std::fixed << std::setprecision(6) << increase << std::endl;\n    }\n}\n\nint main() {\n    int T;\n    std::cin >> T;\n    \n    // Check for limits\n    if (T < 1 || T > INT_MAX) return 1;\n\n    // Call the function to calculate increases\n    calculateIncrease(T);\n\n    return 0;\n}\n\n",
            "mistakes2": "\nIn line p = P / 1000, the division should be by 100 instead of 1000 to correctly convert percentage to probability.\nIn line q_percent = q * 10, the multiplication should be by 100 instead of 10 to accurately convert the probability back to a percentage.\n"
        },
    "Line of Delivery (Part 1)":
        {
            "trick": "\nThe key trick in the solution is that when a stone collides with another, it effectively \"passes through\" by adopting the stationary stone's position and transferring its remaining energy. This behavior means that the final positions of the stones can be determined solely by their initial throwing energies, as the order of stones remains unchanged.\nBy sorting the stones in descending order of their energies, we can directly ascertain their final positions: the highest energy stone will end up furthest to the right, the next highest will be second, and so on. This allows us to simplify the problem to sorting the energies and then identifying which stone is closest to the goal, making the process efficient and straightforward.\n",
            "correct_plan1": "\nfunction solve_curling_problem():\n    read T  // Number of test cases\n    for case_num from 1 to T:\n        read N, G  // Number of stones and goal position\n        initialize energies_list as empty list\n        for i from 1 to N:\n            read E_i  // Energy of the i-th stone\n            append E_i to energies_list\n        \n        // Sort energies_list in descending order to determine final positions\n        sort energies_list in descending order\n        \n        closest_distance = infinity\n        closest_stone_index = -1\n\n        // Determine the closest stone to the goal G\n        for i from 0 to N-1:\n            position = energies_list[i]  // Position of the i-th stone\n            distance = abs(position - G)  // Calculate distance from goal\n\n            // Check if this stone is closer or has a lower index in case of tie\n            if distance < closest_distance or (distance == closest_distance and i < closest_stone_index):\n                closest_distance = distance\n                closest_stone_index = i\n        \n        // Output the results for the current case\n        print \"Case #\", case_num, \": \", closest_stone_index + 1, \" \", closest_distance\n\n// Call the function to execute\nsolve_curling_problem()\n",
            "wrong_plan1": "\nfunction solve_curling_problem():\n    read T  // Number of test cases\n    for case_num from 1 to T:\n        read N, G  // Number of stones and goal position\n        initialize energies_list as empty list\n        for i from 1 to N:\n            read E_i  // Energy of the i-th stone\n            append E_i to energies_list\n        \n        // Sort energies_list in ascending order to determine final positions\n        sort energies_list in ascending order\n        \n        closest_distance = -infinity\n        closest_stone_index = -1\n\n        // Determine the closest stone to the goal G\n        for i from 0 to N-1:\n            position = energies_list[i]  // Position of the i-th stone\n            distance = abs(position - G)  // Calculate distance from goal\n\n            // Check if this stone is closer or has a lower index in case of tie\n            if distance < closest_distance or (distance == closest_distance and i < closest_stone_index):\n                closest_distance = distance\n                closest_stone_index = i\n        \n        // Output the results for the current case\n        print \"Case #\", case_num, \": \", closest_stone_index + 1, \" \", closest_distance\n\n// Call the function to execute\nsolve_curling_problem()\n",
            "wrong_code1": "\n#include <iostream>\n#include <iomanip>\n#include <numeric>\n#include <vector>\n#include <algorithm>\n#include <climits>\n#include <cmath>\n\nvoid solve_curling_problem() {\n    int T; // Number of test cases\n    std::cin >> T;\n\n    for (int case_num = 1; case_num <= T; ++case_num) {\n        int N; // Number of stones\n        long long G; // Goal position\n        std::cin >> N >> G;\n\n        std::vector<long long> energies_list(N); // List to store energy values\n\n        // Read energy values\n        for (int i = 0; i < N; ++i) {\n            std::cin >> energies_list[i];\n        }\n\n        // Sort energies_list in ascending order\n        std::sort(energies_list.begin(), energies_list.end());\n\n        long long closest_distance = LLONG_MAX; // Set to a very high value\n        int closest_stone_index = -1;\n\n        // Determine the closest stone to the goal G\n        for (int i = 0; i < N; ++i) {\n            long long position = energies_list[i]; // Position of the i-th stone\n            long long distance = std::abs(position - G); // Calculate distance from goal\n\n            // Check if this stone is closer or has a lower index in case of tie\n            if (distance < closest_distance || (distance == closest_distance && i < closest_stone_index)) {\n                closest_distance = distance;\n                closest_stone_index = i;\n            }\n        }\n\n        // Output the results for the current case\n        std::cout << \"Case #\" << case_num << \": \" << closest_stone_index + 1 << \" \" << closest_distance << std::endl;\n    }\n}\n\n// Main function to execute the solution\nint main() {\n    solve_curling_problem();\n    return 0;\n}\n\n",
            "mistakes1": "\n1. Sorting Order Mistake:\nMistake: The pseudocode sorts energies_list in ascending order instead of descending order.\nImpact: This will result in incorrect final positions for the stones, as the order of the stones is essential to determine their positions accurately.\n\n2. Initialization of closest_distance:\nMistake: The variable closest_distance is initialized to -infinity instead of infinity.\nImpact: This will lead to incorrect comparisons when finding the closest stone, as any distance calculated will always be greater than closest_distance initially, resulting in no updates to the closest stone index.\n",
            "correct_plan2": "\nFunction solve_curling_stones(T: integer, test_cases: list):\n    for i from 1 to T:\n        (N, G) = test_cases[i].parameters\n        E = test_cases[i].energies\n        \n        // Create a list to store final positions of stones\n        positions = list of length N\n        \n        // Create a list of pairs (energy, index)\n        indexed_energies = [(E[j], j + 1) for j from 0 to N-1]  // 1-based index\n        \n        // Sort by energy in descending order\n        sort indexed_energies by first element (energy) in descending order\n        \n        // Assign positions based on sorted energies\n        for j from 0 to N-1:\n            positions[j] = indexed_energies[j][0]  // Assign energy as position\n        \n        // Find the stone closest to the goal G\n        closest_index = -1\n        closest_distance = infinity\n        \n        for j from 0 to N-1:\n            distance = abs(positions[j] - G)\n            if distance < closest_distance:\n                closest_distance = distance\n                closest_index = j + 1  // Store 1-based index\n            else if distance == closest_distance:\n                // Tie-breaking condition: choose the lower index\n                closest_index = min(closest_index, j + 1)\n        \n        // Output result for the test case\n        print(\"Case #\", i, \": \", closest_index, \" \", closest_distance)\n",
            "wrong_plan2": "\nFunction solve_curling_stones(T: integer, test_cases: list):\n    for i from 1 to T:\n        (N, G) = test_cases[i].parameters\n        E = test_cases[i].energies\n        \n        // Create a list to store final positions of stones\n        positions = list of length N\n        \n        // Create a list of pairs (energy, index)\n        indexed_energies = [(E[j], j + 1) for j from 0 to N-1]  // 1-based index\n        \n        // Sort by energy in ascending order\n        sort indexed_energies by first element (energy) in ascending order\n        \n        // Assign positions based on sorted energies\n        for j from 0 to N-1:\n            positions[j] = indexed_energies[j][0]  // Assign energy as position\n        \n        // Find the stone closest to the goal G\n        closest_index = -1\n        closest_distance = infinity\n        \n        for j from 0 to N-1:\n            distance = abs(positions[j] - G)\n            if distance < closest_distance:\n                closest_distance = distance\n                closest_index = j + 1  // Store 1-based index\n            else if distance == closest_distance:\n                // Tie-breaking condition: choose the higher index\n                closest_index = max(closest_index, j + 1)\n        \n        // Output result for the test case\n        print(\"Case #\", i, \": \", closest_index, \" \", closest_distance)\n",
            "wrong_code2": "\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <iomanip>\n#include <climits>\n\nusing namespace std;\n\nvoid solve_curling_stones(int T, const vector<pair<pair<int, int>, vector<long long>>& test_cases) {\n    for (int i = 1; i <= T; ++i) {\n        int N = test_cases[i - 1].first.first;  // Number of stones\n        int G = test_cases[i - 1].first.second; // Goal position\n        const vector<long long>& E = test_cases[i - 1].second; // Energies\n\n        // Create a vector to store final positions of stones\n        vector<long long> positions(N);\n\n        // Create a vector of pairs (energy, index)\n        vector<pair<long long, int>> indexed_energies(N);\n        for (int j = 0; j < N; ++j) {\n            indexed_energies[j] = {E[j], j + 1};  // 1-based index\n        }\n\n        // Sort by energy in ascending order\n        sort(indexed_energies.begin(), indexed_energies.end());\n\n        // Assign positions based on sorted energies\n        for (int j = 0; j < N; ++j) {\n            positions[j] = indexed_energies[j].first;  // Assign energy as position\n        }\n\n        // Find the stone closest to the goal G\n        int closest_index = -1;\n        long long closest_distance = LLONG_MAX;\n\n        for (int j = 0; j < N; ++j) {\n            long long distance = abs(positions[j] - G);\n            if (distance < closest_distance) {\n                closest_distance = distance;\n                closest_index = j + 1;  // Store 1-based index\n            } else if (distance == closest_distance) {\n                // Tie-breaking condition: choose the higher index\n                closest_index = max(closest_index, j + 1);\n            }\n        }\n\n        // Output result for the test case\n        cout << \"Case #\" << i << \": \" << closest_index << \" \" << closest_distance << endl;\n    }\n}\n\nint main() {\n    int T;\n    cin >> T;\n\n    vector<pair<pair<int, int>, vector<long long>>> test_cases(T);\n    for (int i = 0; i < T; ++i) {\n        int N, G;\n        cin >> N >> G;\n        vector<long long> E(N);\n        for (int j = 0; j < N; ++j) {\n            cin >> E[j];\n        }\n        test_cases[i] = {{N, G}, E};\n    }\n\n    solve_curling_stones(T, test_cases);\n    return 0;\n}\n",,
            "mistakes2": "\n1. Sorting Order: The pseudocode incorrectly states to sort by energy in ascending order instead of descending order.\n2. Tie-breaking Condition: The pseudocode incorrectly states to choose the higher index in the event of a tie instead of the lower index.\n"
        },
    "Walk the Line":
        {
            "trick": "\nTo solve the problem, the key tricks are:\n\nOptimal Pairing: Always have the two slowest travelers cross together while the fastest traveler returns with the flashlight, minimizing the time spent on return trips.\nChauffeur Strategy: Designate the fastest traveler as the one who always carries the flashlight and wheelbarrow, making all return trips.\nTime Calculation: Use a formula to compute the total crossing time based on the crossing times of the fastest and second-fastest travelers, ensuring it does not exceed the allowed time K.\nEdge Case: For a single traveler, simply check if their crossing time is less than or equal to K.\n",
            "correct-plan1": "\nFunction canCrossBridge(test_cases):\n    For each test_case in test_cases:\n        Read N and K\n        Initialize an empty list S to store crossing times\n\n        For i from 1 to N:\n            Read S_i\n            Append S_i to S\n\n        Sort S in ascending order\n        Let min_time = S[0]  // Fastest traveler time\n        Let total_time = 0\n\n        If N == 1:\n            If S[0] <= K:\n                Output \"Case #i: YES\"\n            Else:\n                Output \"Case #i: NO\"\n            Continue to next test_case\n\n        // Calculate total crossing time for N travelers\n        If N == 2:\n            total_time = max(S[0], S[1])\n            If total_time <= K:\n                Output \"Case #i: YES\"\n            Else:\n                Output \"Case #i: NO\"\n            Continue to next test_case\n\n        // General case for N > 2\n        total_time = 0\n        // Calculate the total crossing time based on optimal strategy\n        total_time += (N - 1) * 2 * min_time  // Forward trips\n        total_time += (N - 2) * S[1]          // Return trips of second fastest\n\n        If total_time <= K:\n            Output \"Case #i: YES\"\n        Else:\n            Output \"Case #i: NO\"\n",
            "wrong_plan1": "\nFunction canCrossBridge(test_cases):\n    For each test_case in test_cases:\n        Read N and K\n        Initialize an empty list S to store crossing times\n\n        For i from 1 to N:\n            Read S_i\n            Append S_i to S\n\n        Sort S in descending order\n        Let min_time = S[0]  // Fastest traveler time\n        Let total_time = 0\n\n        If N == 1:\n            If S[0] <= K:\n                Output \"Case #i: YES\"\n            Else:\n                Output \"Case #i: NO\"\n            Continue to next test_case\n\n        // Calculate total crossing time for N travelers\n        If N == 2:\n            total_time = min(S[0], S[1])\n            If total_time <= K:\n                Output \"Case #i: YES\"\n            Else:\n                Output \"Case #i: NO\"\n            Continue to next test_case\n\n        // General case for N > 2\n        total_time = 0\n        // Calculate the total crossing time based on optimal strategy\n        total_time += (N - 1) * 2 * min_time  // Forward trips\n        total_time += (N - 2) * S[1]          // Return trips of second fastest\n\n        If total_time <= K:\n            Output \"Case #i: YES\"\n        Else:\n            Output \"Case #i: NO\"\n",
            "wrong_code1": "\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <iomanip>\n#include <numeric>\n#include <climits>\n\nvoid canCrossBridge(int test_cases) {\n    for (int i = 1; i <= test_cases; ++i) {\n        int N, K;\n        std::cin >> N >> K;\n\n        std::vector<long long> S(N);\n        \n        // Read crossing times\n        for (int j = 0; j < N; ++j) {\n            std::cin >> S[j];\n        }\n\n        // Sort in descending order\n        std::sort(S.begin(), S.end(), std::greater<long long>());\n        \n        long long min_time = S[0];  // Fastest traveler time\n        long long total_time = 0;\n\n        // Handle single traveler case\n        if (N == 1) {\n            if (S[0] <= K) {\n                std::cout << \"Case #\" << i << \": YES\n\";\n            } else {\n                std::cout << \"Case #\" << i << \": NO\n\";\n            }\n            continue;\n        }\n\n        // Handle two travelers case\n        if (N == 2) {\n            total_time = std::min(S[0], S[1]);\n            if (total_time <= K) {\n                std::cout << \"Case #\" << i << \": YES\n\";\n            } else {\n                std::cout << \"Case #\" << i << \": NO\n\";\n            }\n            continue;\n        }\n\n        // General case for N > 2\n        total_time += (N - 1) * 2 * min_time;  // Forward trips\n        total_time += (N - 2) * S[1];          // Return trips of second fastest\n\n        // Check if total crossing time is within limits\n        if (total_time <= K) {\n            std::cout << \"Case #\" << i << \": YES\n\";\n        } else {\n            std::cout << \"Case #\" << i << \": NO\n\";\n        }\n    }\n}\n\nint main() {\n    int T;\n    std::cin >> T;  // Read number of test cases\n    canCrossBridge(T);  // Call the function with the number of test cases\n    return 0;\n}\n",
            "mistakes1": "\nMistake 1: The sorting of the list S is done in descending order instead of ascending order. This affects the identification of the fastest traveler and the second fastest.\nMistake 2: In the case where N=2, the total crossing time is calculated using min(S[0], S[1]), which is incorrect. It should use max(S[0], S[1]) since both travelers cross together, and the time taken is determined by the slower traveler.\n", 
            "correct_plan2": "\nfunction canCrossBridge(T, testCases):\n    for caseNumber from 1 to T:\n        N, K = testCases[caseNumber].N, testCases[caseNumber].K\n        S = testCases[caseNumber].S  // list of crossing times\n\n        if N == 1:\n            // Check if the single traveler can cross\n            if S[0] <= K:\n                print(\"Case #\", caseNumber, \": YES\")\n            else:\n                print(\"Case #\", caseNumber, \": NO\")\n            continue\n        \n        // Sort crossing times\n        S.sort()\n\n        // Assign minimum crossing time to the fastest traveler\n        fastestTime = S[0]\n        \n        // Calculate the total time required for crossing\n        totalTime = 0\n        \n        // Number of crossings needed\n        tripsNeeded = N - 1\n        \n        // Calculate total time based on optimal crossing strategy\n        if N % 2 == 0:\n            // For even number of travelers\n            totalTime = (fastestTime * (N // 2)) + (S[1] * (N // 2 - 1))\n        else:\n            // For odd number of travelers\n            totalTime = (fastestTime * (N // 2 + 1)) + (S[1] * (N // 2))\n        \n        // Total time for all trips (forward and return)\n        totalTime += (2 * tripsNeeded * fastestTime)\n\n        // Check if total time is within the allowed limit\n        if totalTime <= K:\n            print(\"Case #\", caseNumber, \": YES\")\n        else:\n            print(\"Case #\", caseNumber, \": NO\")\n\n// Input parsing\nT = readInteger()\ntestCases = []\nfor i from 1 to T:\n    N, K = readTwoIntegers()\n    S = readListOfIntegers(N)\n    testCases.append({N: N, K: K, S: S})\n\ncanCrossBridge(T, testCases)\n",
            "wrong_plan2": "\nfunction canCrossBridge(T, testCases):\n    for caseNumber from 1 to T:\n        N, K = testCases[caseNumber].N, testCases[caseNumber].K\n        S = testCases[caseNumber].S  // list of crossing times\n\n        if N == 1:\n            // Check if the single traveler can cross\n            if S[0] <= K:\n                print(\"Case #\", caseNumber, \": YES\")\n            else:\n                print(\"Case #\", caseNumber, \": NO\")\n            continue\n        \n        // Sort crossing times\n        S.sort()\n\n        // Assign minimum crossing time to the fastest traveler\n        fastestTime = S[0]\n        \n        // Calculate the total time required for crossing\n        totalTime = 0\n        \n        // Number of crossings needed\n        tripsNeeded = N - 1\n        \n        // Calculate total time based on optimal crossing strategy\n        if N % 2 == 0:\n            // For even number of travelers\n            totalTime = (fastestTime * (N // 2)) + (S[1] * (N // 2 - 1))\n        else:\n            // For odd number of travelers\n            totalTime = (fastestTime * (N // 2 + 1)) + (S[0] * (N // 2))\n        \n        // Total time for all trips (forward and return)\n        totalTime += (2 * tripsNeeded * fastestTime)\n\n        // Check if total time is within the allowed limit\n        if totalTime <= K:\n            print(\"Case #\", caseNumber, \": YES\")\n        else:\n            print(\"Case #\", caseNumber, \": NO\")\n\n// Input parsing\nT = readInteger()\ntestCases = []\nfor i from 1 to T:\n    N, K = readTwoIntegers()\n    S = readListOfIntegers(N)\n    testCases.append({N: N, K: K, S: S})\n\ncanCrossBridge(T, testCases)\n",
            "wrong_code2": "\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <climits>\n#include <iomanip>\n#include <numeric>\n\nusing namespace std;\n\nvoid canCrossBridge(int T, vector<pair<int, pair<int, vector<long long>>>> testCases) {\n    for (int caseNumber = 1; caseNumber <= T; ++caseNumber) {\n        int N = testCases[caseNumber - 1].first;\n        int K = testCases[caseNumber - 1].second.first;\n        vector<long long> S = testCases[caseNumber - 1].second.second;\n\n        if (N == 1) {\n            // Check if the single traveler can cross\n            if (S[0] <= K) {\n                cout << \"Case #\" << caseNumber << \": YES\" << endl;\n            } else {\n                cout << \"Case #\" << caseNumber << \": NO\" << endl;\n            }\n            continue;\n        }\n\n        // Sort crossing times\n        sort(S.begin(), S.end());\n\n        // Assign minimum crossing time to the fastest traveler\n        long long fastestTime = S[0];\n\n        // Calculate the total time required for crossing\n        long long totalTime = 0;\n\n        // Number of crossings needed\n        int tripsNeeded = N - 1;\n\n        // Calculate total time based on optimal crossing strategy\n        if (N % 2 == 0) {\n            // For even number of travelers\n            totalTime = (fastestTime * (N / 2)) + (S[1] * (N / 2 - 1));\n        } else {\n            // For odd number of travelers\n            totalTime = (fastestTime * (N / 2 + 1)) + (S[0] * (N / 2));\n        }\n\n        // Total time for all trips (forward and return)\n        totalTime += (2 * tripsNeeded * fastestTime);\n\n        // Check if total time is within the allowed limit\n        if (totalTime <= K) {\n            cout << \"Case #\" << caseNumber << \": YES\" << endl;\n        } else {\n            cout << \"Case #\" << caseNumber << \": NO\" << endl;\n        }\n    }\n}\n\nint main() {\n    int T;\n    cin >> T;\n    vector<pair<int, pair<int, vector<long long>>>> testCases(T);\n\n    for (int i = 0; i < T; ++i) {\n        int N, K;\n        cin >> N >> K;\n        vector<long long> S(N);\n        for (int j = 0; j < N; ++j) {\n            cin >> S[j];\n        }\n        testCases[i] = {N, {K, S}};\n    }\n\n    canCrossBridge(T, testCases);\n    return 0;\n}\n",
            "mistakes2": "\n1. In the total time calculation for the even case, it incorrectly uses S[1] instead of S[0].\n2. In the total time calculation for the odd case, it uses S[0] for the second term instead of S[1], which should represent the second fastest traveler's time.\n"
        },
    "Line of Delivery (Part 2)":
        {
            "trick": "",
            "correct_plan1": "",
            "wrong_plan1": "",
            "mistakes1": "",
            "correct_plan2": "",
            "wrong_plan2": "",
            "mistakes2": ""
        }
}
